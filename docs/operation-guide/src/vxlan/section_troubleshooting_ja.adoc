[[vxgw_troubleshooting]]
= VTEP/VXGW設定のトラブルシューティング

VTEPのデプロイメントには、比較的数多くのピース移動ならびに潜在する障害ポイントがあります。この手引文書は、MidoNetのトラブルシューティングと、MidoNetとVTEPとの統合に関するトラブルシューティングに焦点を当てます。ロジカルスウィッチの設定に関する具体的な事柄に関しては、ベンダーが提供する文書を参照してください。

*MidoNet APIはVTEPに接続することができますか*

xref:cli_add_vtep[]が説明しているとおりにVTEPを追加する手順を踏むと、以下のような内容が出力されます。

[source]
midonet> vtep add management-ip 119.15.120.123 management-port 6633 tunnel-zone tzone0
management-ip 119.15.120.123 management-port 6633 tunnel-zone tzone0 connection-state CONNECTED

既にMidoNetに追加してあるVTEPについても同じ内容が出力されます。

状態がCONNECTEDであることに注意します。ERROR状態であるということは、VTEPのマネージメントIPがMidoNet APIからは届かないということを意味します。

* VTEPはきちんと設定されていますか？*

VTEPがERROR状態となる典型的な事例としては、VTEP OVDSBインスタンスの設定に誤りがある場合があります。コンソール上で次のコマンドを実行すると、この状況を検証することができます。

[source]
ovsdb-client dump hardware_vtep

Physical_Switchテーブルまでスクロールダウンしてみてください。次のような画面になります。

[source]
----
Physical_Switch table
_uuid                                description         management_ips   name        ports                                  switch_fault_status tunnel_ips
------------------------------------ ------------------- ---------------- ----------- -------------------------------------- ------------------- ------------
3647f020-9ecf-4854-8f75-9011b8c9996a "VTEP DESCRIPTION"  ["192.168.2.14"] "VTEP NAME" [698ede89-31f8-4797-a885-1b2dd4c585e3] []                  ["10.0.0.1"]
----

エントリーが存在するかどうかを確認します。また、management_ipsフィールドおよびtunnel_ipsフィールドが物理的な設定と対応しているかどうかを確認します。マネージメントIPとは、“vtep add”コマンド上でこれから使うことになるIPです。トンネルIPはこの時点では関系がありませんが、それでもMidoNetはこのフィールドにバリューが表示されることを予測しています。

*OVSDBインスタンスは実行されていますか、また、OVSDBインスタンスにアクセスすることはできますか？*

もしもMidoNet APIがVTEPリスト上でERRORを表示していた時、自分の設定に誤りがないのであれば、OVSDBインスタンスが、自分がvtep add callの中で特定しているマネージメント-ポートと同じマネージメント-ポート上で聞いていないかどうかを確認します。

MidoNetREST API(ならびにCoordinator)を実行しているホストから、VTEPマネージメントインターフェースIPおよびそのポートへのテルネット接続を確立できないかを試してみます。この時、VTEPマネージメントインターフェースIP は192.168.2.13であり、ポート番号は6632であるということを前提にします。

[source]
telnet 192.168.2.13 6632

上手く接続できると次のような内容が出力されます。

[source]
192.168.2.13を試みています..
ローカルホストに接続しました.
エスケープキャラクターは '^]'.

これは、今、あるTCPソケットがあり、そのTCPソケットは正しいポート上で聞いているということを意味します。
これで、OVSDBが反応するかどうかを確認することができます。もし反応しないのであれば、手元のスウィッチマニュアルを調べて、選択したTCPポートでの接続がないかを聞いてみます。

出力内容が正しければ、コンソールに次の内容を入力します。

[source]
{"method":"list_dbs","id":"list_dbs","params":[]}

以下の内容が出力されることが望ましいです。

[source]
{"id":"list_dbs","result":["hardware_vtep"],"error":null}

括弧の中の”result"の後に続く文字はその時によって変わりますが、”hardware_vtep”という文字は必ず入っていなければなりません。これは、このOVSDBのインスタンスにVTEPスキーマが存在しているということを示しています。この文字が出力されていない場合には、そのVTEPは、自らのOVSDBインスタンスにhardware_vtepスキーマを含んでいない可能性が高いと言えます。手元のスイッチ文書の指示内容を参照して設定を行ってください。

*VTEPもバインディングも追加したがトラフィックが全く通過しない場合*

はじめに、MidoNet APIの中で、VxLANゲートウェイ・サービスを有効化したかを確認します。このサービスは初期設定時には有効になっていないのですが、VTEPを設定し、同期状態を設定するためには必要なサービスです。MidoNet APIの設定ファイルを開きます。

[source]
vi /usr/share/midonet-api/WEB-INF/web.xml

下記セクションが見つかるまでスクロールダウンします。

[source]
<!-- VXLAN gateway configuration -->
<context-param>
    <param-name>midobrain-vxgw_enabled</param-name>
    <param-value>true</param-value>
</context-param>

VxLAN ゲートウェイのコーディネーションに展開したいMidoNet APIインスタンスの中にあるバリューは、その全てが"true”と設定してあることに注目してください。

*VxLAN ゲートウェイ・サービスが開始したことを確認してください*

VxLANゲートウェイ・サービスは、複数のMidoNet APIインスタンスで有効になっているかもしれません。そのMidoNet APIインスタンスの全てがNetwork State Database(NSDB)を通して調整され、その中からリーダー役が選ばれて、そのリーダーが調整タスクの全てを実行します。MidoNet APIインスタンスがリーダー役を担うと、(/var/log/tomcat/catalina.out)ログには、次のINFOメッセージが表示されます。

[source]
"I am the VxLAN Gateway leader! /"

既に、別のインスタンスがリーダー役になっていたのであれば、残りのインスタンスは全て、次のINFOメッセージを表示します。

[source]
"私はもうVXLANゲートウェイリーダーではなくなりました。パッシプになります”

MidoNet APIのインスタンスのうちの少なくとも1つのインスタンスが、自らがVxLAN ゲートウェイリーダーになったことを示す肯定メッセージを表示します。この時点以降、生成されるログメッセージを読むためには、このインスタンスを観察していく必要があります。

*VxLAN ゲートウェイリーダーが、VTEPならびにネットワークを拾い上げているかを検証します*

VxLAN ゲートウェイ・サービスは、MidoNetのNSDBの中にあるニュートロンネットワーク全てをスキャンし、VTEPのいずれかにバインドしているものへの監視を開始します。

ニュートロンネットワークがVTEPにバインドしている時には、INFOログには必ず次のメッセージが表示されます。付与されているニュートロンネットワークに関連したログメッセージには全て、適切なUUIDのタグが付いていることに着目してください。

[source]
INFO c68fa502-62e5-4b33-9f2f-d5d0257deb4f - Successfully processed update

編集をすることで、特定のネットワークに関連した更新内容をフィルタリングすることができます。

[source]
vi /usr/share/midonet-api/WEB-INF/classes/logback.xml

このファイルに記述してある詳細な指示にしたがって、コーディネーターの中で様々に異なる各種プロセスを有効にします。表示を簡略化するため、下方に示したメッセージでは、ネットワークのUUIDタグを省略しています。

前述のとおり、ニュートロンネットワーク毎に以下のようなメッセージが確認できます。

[source]
<NETWORK_UUID>ネットワークがVxLANゲートウェイの一部になりました。

この段階で上手くいかない典型的な事例として考えられるのが、NSDBへのアクセス時にエラーが発生する場合です。たとえば次のような事例です。

[source]
ネットワークの状態を読みだすことができません。

復旧可能なエラーが見つかった場合には、MidoNetコントローラーがログの中にWARNを表示して、NSDBへの接続の復旧を試みます。復旧が不可能なエラーについては、ERRORと表示されます。

ログがNSDBへの接続時に問題が発生したことを表示した場合には、NSDBが有効であるかを確認し、また、MidoNet APIがうまくNSDBにアクセスできるのかどうかを検証します。

*MidoNetコーディネーターがMACをVTEPと同期させているかどうかを検証します*

NDSBから、ニュートロンネットワーク設定を獲得し終えると、MidoNet APIのログには下方に記載したメッセージが表示されます (これらのメッセージはその他のメッセージと混ざって表示されるかかもしれませんので注意してください）

[source]
Starting to watch MAC-Port table in <NEUTRON_UUID>
Starting to watch ARP table in <NEUTRON_UUID>
今ネットワークの状態を監視しています

これらのメッセージは、MidoNetコーディネーターがネットワークの状態を監視していることを示していて、この監視活動はVTEPと同期をとります。

*MidoNetコーディネーターがVTEP(s)と接続していることを検証します*
MidoNetコーディネーターはまた、ネットワーク間で状況を交換するためにプロセスをブートストラップし、Port-vlanペアつきのVTEPはその全てがMidoNetコーディネーターにバインドします。コントローラーが新しいVTEPの中になんらかのポート-vlanペアを見つけると次のメッセージを表示します　(ここでは、マネージメントipおよびマネージメントポートはそれぞれ192.168.2.13および6632であることが前提です。)

[source]
新しいVTEPへのバインディングが192.168.2.13:6632に見られます。

この時点で、MidoNetコーディネーターは、このVTEPのマネージメントIPへの確実な接続を確立させ、MidoNet REST APIを通じて設定されたバインディングがVTEPの中で正しく反映されているようにします。通常は次のようなものが出力されます(出力内容は他のメッセージと混ざることがあります。)


[source]
Consolidate state into OVSDB for <VXLAN GATEWAY DESCRIPTION>
Logical switch <LOGICAL_SWITCH_NAME> exists: ..
Syncing port/vlan bindings: <PORT_VLAN PAIRS>

もしもコーディネーターがVTEPに接続をする上でなんらかのエラーを報告した時には、コーディネーターは自動的に接続を試みますが、VTEPがup状態でアクセス可能かどうかは自分でも検証してください。

統合状態の成功を受けて、MidoNetはMACの同期化とARPエントリーとを開始します。

[source]
Joining <VXLAN_GATEWAY_DESCRIPTION> and pre seeding <NUMBER> remote MACs
<NUMBER>ローカルMACとのスナップショットをエミットします。
未認知-dstをアドバタイズして、オーバーフロー状態のトラフィックを受け取ります..

VTEPへの接続エラーはこの時点まで到達すれば起きうることですが、コーディネーターが丁寧に状況に対処してください。

もしもMidoNetが修復不可能なエラーをみつけた場合には、次のWARNメッセージが表示されます(マネージメントポートおよびidは前記のものと同じであることが前提）

[source]
192.168.2.13：6632において、VTEPを上手くブートストラップすることができませんでした。

MidoNetコーディネーターは、このニュートロンネットワークが再びアップデートされるまではこのニュートロンネットワークを無視します。MidoNetコーディネーターは、設定されているその他のネットワークとの動作は継続することができます。

* MidoNetコーディネーターが状況と同期を取っていることを確認します。*

この時点までエラー表示が全くなかった場合には、上述のlogback.xml ファイルを編集し、vxgwプロセスの中でDEBUGログを有効にします。


[source]
<!-- <logger name="org.midonet.vxgw" level="DEBUG" /> -->

`<!--` and `-->` タグを取り除くことでこの設定を有効にして、APIログがDEBUGメッセージを表示し始めるまで数秒間待ちます。さらに細かい情報を見るにはDEBUGではなくTRACEを選択します。(パフォーマンスに大きく影響を与えてしまうほどに冗長な情報はありません。)

以下のようなメッセージは、MidoNetコーディネーターがMidoNetとVTEP間でMACどうしを交換することに成功したことを示しています。

[source]
TRACE c68fa502-62e5-4b33-9f2f-d5d0257deb4f - Learned: MacLocation { logicalSwitchName=mn-c68fa502-62e5-4b33-9f2f-d5d0257deb4f, mac=96:8f:e8:12:33:55, vxlanTunnelEndpoint=192.168.2.16 }

このメッセージは、与えられているMACに関するアップデータが、ニュートロンネットワークc68fa502-62e5-4b33-9f2f-d5d0257deb4fに所属するロジカルスウィッチ上でみつかったことを示しています。この場合、vxlanトンネルエンドポイントは192.168.2.16だったということで、つまりMACはトンネルエンドポイントで見つけることができることを示しています。ポートからMACを取り除かれたことが、vxlanTunnelEndpoint=null(これは「MACはいずれのポートにもいません」という意味)という文字で判ります。

*VxLANトンネルが確立したことを検証します*

コーディネーターが正常に作動しているのにもかかわらず、トラフィックがいまだに流れないのであれば、VTEPsならびにMidoNetホストが上手くVxLANトンネルを確立できるか検証すべきです。

VMから通信したい相手先サーバーへのピングを稼働させながら、VTEP上の相手先サーバーとの通信を試みているVMのホストであるMidoNet コンピュートにログインします。次のコマンドを実行します。

[source]
tcpdump -leni any port 4789

MidoNetコンピュートが192.168.2.14であることを前提とし、また、VTEPのトンネルIPが192.168.2.17であることも前提にすると、出力内容は以下のような内容となるはずです（お使いのtcpdumpバージョンに応じて変わります。）

[source]
15:51:28.183233 Out fa:16:3e:df:b7:53 ethertype IPv4 (0x0800), length 94: 192.168.2.14.39547 > 192.168.2.17.4789: VXLAN, flags [I] (0x08), vni 10012
aa:aa:aa:aa:aa:aa > ff:ff:ff:ff:ff:ff, ethertype ARP (0x0806), length 42: Request who-has 10.0.0.1 tell 10.0.0.10, length 28
15:51:28.186891  In fa:16:3e:52:d8:f3 ethertype IPv4 (0x0800), length 94: 192.168.2.17.59630 > 192.168.2.13.4789: VXLAN, flags [I] (0x08), vni 10012
cc:dd:ee:ee:ee:ff > aa:aa:aa:aa:aa:aa, ethertype ARP (0x0806), length 42: Reply 10.0.0.10 is-at cc:dd:ee:ee:ee:ff

1行目は、MidoNetエージェント(192.168.2.14)がトンネル化されたパケットをVTEP(192.168.2.17:4789)に向けて放出しており、その時には10012をVNIDとして使用していることを示しています。カプセル化されたパケットが2行目に表示されており、このパケットは、10.0.0.1.サーバーに関して、ip10.0.0.10つきのVMからのARP REQUESTに対応しています。

この事例では、VTEPが3行目で正しく回答をしていて、そこでは同じVNIDの返信パケットを表示しています。

VTEP上では、同じ事例をリバースして適用することもできます。VTEPと接続している物理的なサーバーがピングをすると、トンネル化されたパケットがMidoNetエージェントに向けて発生し、類似の返信パケットを受領します。

*MidoNetエージェントがトラフィックを放出していません*

+mn-conf(1)+ でVXLAN関連のオプションを検証します。debugモードでMidoNetAgentのログを調べて、パケットをドロップしているあるいはシミュレーションに向けてエラーを投げているといったようなことをしているシミュレーションがニュートロンネットワーク上にないかどうか探します。

*VTEPはトンネル上でトラフィックを放出していません*

VTEP設定が、MidoNet REST APIを通じて設定したバインディングを反映していることを確認します。スイッチの中に今存在するVTEPsをリスト化するには次のコマンドを使用します。

[source]
vtep-ctl list-ls

このプログラムは、スウィッチの中に今存在するロジカルスウィッチ全てを表示します。UUID c68fa502-62e5-4b33-9f2f-d5d0257deb4fつきのニュートロンネットワークをバインドさせると、リストの中には次のアイテムが表示されます。

[source]
mn-c68fa502-62e5-4b33-9f2f-d5d0257deb4f

midonet-cliの中でport-vlanバインディングを作成するために使ったポート上のバインディングをリスト化します。ここでは、ポート１を保有していて、ポート１とvlan93とのバインディングを作成したと仮定します。出力される内容は次のようになります。

[source]
vtep-ctl list-bindings <VTEP_NAME> port1
0093 mn-c68fa502-62e5-4b33-9f2f-d5d0257deb4f

"vtep-ctl list-ps"コマンドを使うことによってVTEP_NAMEを見つけることができます。

出力内容の中に予期しなかったものがあった場合には、MidoNetコーディネーターはNSDBからの設定を統合することができていない可能性が高いと考えられます。MidoNet APIログを検証し、該当するエラーを見つけて修正してください。

*MACsが正しくVTEPと同期しているかを検証します*

最後に紹介するのがVTEPのデータベースに存在するローカルMACsならびに遠隔MACsをリスト化する方法です。

[source]
vtep-ctl list-local-macs mn-c68fa502-62e5-4b33-9f2f-d5d0257deb4f

このプログラムは、ローカルポート上で観察したトラフィックからVTEPが学習したMACs全てを表示することができます。ローカルサーバーが正しく設定してあれば、普通は、サーバのMACをここで見ることができます。

次のコマンドは、遠隔地MACを表示します。

[source]
vtep-ctl list-remote-macs mn-c68fa502-62e5-4b33-9f2f-d5d0257deb4f

このリストは、MidoNet VMsや他のVTEPの中に存在するMACsを表示します。これらのMACsはMidoNetコーディネーターによって注入されています。

これらの手順のいずれかが期待する内容を出力しない場合には、同期化処理が上手くいっていないことが考えられます。詳細を確認するためにMidoNet API ログを調査してください。


