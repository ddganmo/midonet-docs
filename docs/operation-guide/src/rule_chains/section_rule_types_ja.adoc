[[rule_types]]
= ルール種別

本章ではルール種別について説明します。

++++
<?dbhtml stop-chunking?>
++++

== ACCEPT, DROP, REJECT, RETURN
　(受け入れる、ドロップする、リジェクトする、返却する)

これらのルール種別はパケットを修正することはありません。これらの種別は、ただ、各々の種別/名前に対応するアクションを返却することだけを行ないます。これらのルールのうちの１つを構築する時には、ただ、種別とその条件を規定するだけで充分です。そのルールが呼びだされると、そのルールは、パケットが、そのルールの条件とマッチするかどうかを調べ、もしもマッチしている場合には、そのルールの種別/名前に関連したアクションを返却します。たとえば、もしもルール種別がDROPであったとしたら、(DROP, packet)と返却します。パケットが条件とマッチしない場合には、そのルールは呼び出し元に(CONTINUE, packet)と返却します。

ルールにはCONTINUEというルール種別はありません。なぜならば、そのようなルールがあれば、パケットの内容にかかわらず、(CONTINUE, packet)と返却するからです。このルールはパケットを修正することがありませんので、そのルールは、意味のないオペレーションになります。

== DNAT, SNAT

これらのルール種別はパケットを修正します。いずれのルールもソース/行き先のネットワークアドレスを書き換えますし、TCP/UDPポート番号をも書き換えます。これらいずれかのルールのうちの１つを構築する時には、パケットとマッチさせるための条件とは別に、次に挙げる2つの事柄を規定する必要があります：

* パケットのソース/行き先アドレスをマッチさせるための変身しうる標的先リスト

* このルールを呼び出した呼び出しチェーンに返却すべきnext_action。法定上のバリューは以下のとおりです：ACCEPT, CONTINUE, ならびにRETURN.

このnext_actionは、チェーンをより柔軟に構築することを可能にしてくれます。パケットをマッチさせた後、つまりパケットを修正後(そのアドレスの一部を変換した後)、次にすべきことを選択することは複雑な作業であり、自分次第ということになります。利用できる選択肢は次のとおりです：

*全てのルールチェーンから退出します(ACCEPT)。

*現在のチェーンの中で、次のルールを呼び出す(CONTINUE)。

* もしも呼出し元がチェーンであって、そのチェーンにもう１つの(次の)ルール(RETURN)がある場合には、現在のチェーンから退出し、コールを発している方のチェーンの次のルールを呼び出す。

注意すべき点を書きます。DNATルールもSNATルールも、送信フロー/パケットと返信フロー/パケットとの間を区別できません。接続を開始したパケットと同じ方向に向かって進むパケットは送信フローに所属し、その逆方向に進むパケットは返信フローに所属するということなのです。DNATルールもSNATルールも、たんに条件を調べに行くだけで、もしも条件がマッチすれば、各々のルールは変換を適用し、それからその状況を記録することによって、返信フローが処理されている間に条件がアクセスされることを可能にします。つまり、変換マッピングは保存された上で返信トラフィックフロー用のリバース変換を実行するために使われているということなのです。(“REV_DNAT,REV_SNAT”を参照してください。)　よって、次の処理を正しく実行することが重要です：

*アドレス/ポート変換をリバースするためにはREV_DNAT and REV_SNAT ルールを使います。

* プレルーティング時にはDNAT and REV_SNATルールの指示を正しく出し、ポストルーティング時にはSNAT and REV_DNATルールの指示を正しく出すようにします。

* ポストルーティング時にDNATルールを使用したり、プレルーティング時にSNATルールを使用することは避けるようにします。

== REV_DNAT, REV_SNAT

これらのルール種別はパケットを修正します。また、これらのルール種別はソース(SNAT)/行き先(DNAT)ネットワークアドレスおよびTCP/UDPポート番号を書き換えます。これらのルールのうちの１つを構築する場合には、パケットをマッチさせるための条件とは別に、パケットがマッチし同時にリバース変換がみつかった時に、ルールの呼び出し元に返却すべきnext_actionを規定しなければなりません。(そうしなければCONTINUEが返却されます。)　パケットがこれらのルールのうちの１つとマッチした時には、そのルールは一元化されたマップ(ソフト状態のもの)の中でリバース変換を検索し、それをパケットに適用します。よって、これらのルールの場合には、たとえばDNATルールやSNAルールの時のように変換する標的先を規定する必要がないのです。

== Jump

このルール種別はパケットを修正するようなことはけっしてありません。これらのルールのうちの１つを構築する時には、パケットをマッチさせるための条件とは別に、jump_targetを規定する必要があります：つまり、マッチしたパケットにたいして呼び出すべきルールチェーンの名前を規定すべきなのです。このjump_targetが、ジャンプルールを含むチェーンの名前であってはならない点に注意します。なぜならば、そうであればルール-チェーンループを生じさせてしまうからです；ルール-チェーンのルーピングは避けなければなりません。ループを避けるために、ふぉわーディングロジックは、ルール-チェーンloopsを探知し、すでに訪問したチェーンを再び訪問するパケットがあればそのパケットをドロップします。

パケットがジャンプルールの条件とマッチした時に取るアクションは、そのルールがプレルーティング時に呼び出されたのか、あるいはポストルーティング時に呼び出されたのかによって変わってきます：

* プレルーティング時にそのルールが呼び出された時：そのルールは、自らのjump_targetが規定したルールチェーンをみつけて、入口ポートでパケットを処理するようチェーンを呼びます。

* ポストルーティング時に呼び出された時には、そのルールは、入口ポート、出口ポート上でパケットを処理するチェーンを呼びます。

* チェーンが見つからない場合には、そのジャンプルールは初期値であるCONTINUEを返却します。そうしない時には、ジャンプルールはルールチェーンを呼び出して、リターンされてきたもの(next_action,new_packet)をそのまま返却します。
