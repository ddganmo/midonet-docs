[[rule_conditions]]
= ルールの条件

どのルールにも必ず、パケットがマッチする１つの「条件オブジェクト」があります。この「条件オブジェクト」があるので、ルールを適用することができるのです。

ジャンプルールを例に説明してみます。パケットがジャンプの「条件オブジェクト」とマッチすると、このパケットにたいするルール処理は、ジャンプの標的チェーンの中で継続して行なわれます。このパケットがマッチしなかった場合には、ジャンプ自身のルールチェーンの中でルールがジャンプの後に従うことで処理が継続されます。

「条件オブジェクト」は属性のセットあるいは属性の組み合わせを規定します。属性とは、パケットのヘッダーの内容を簡単に記述したものです。属性の事例には以下のようなものがあります。

*そのパケットのTCP/UDPポート番号は500と1000の間の数字です
*そのパケットのソースIPアドレスは10.0.0.0/16の中にあります。

 [NOTE]
「条件」は、パケットがルールに到達した時のパケットの状態にたいしてチェックされます。たとえば、それ以前のルールがパケットのポート番号を修正していた場合、現在のルールの条件はもともとのポート番号にたいしてではなく、修正後のポート番号にたいしてのチェックとなります。

「条件」を形成するには、属性をいくつか規定します。(ほとんどの属性は、CLIを使用することにより任意でインバートすることができます。)　感嘆符(！) を入力するか、” bang”シンボルを入力するとインバートすることができます。詳しくは‘CLI Rule Chain Attributes That Match Packets”という名前のテーブルを見てください。たとえばsrc属性をインバートしたとすると、インバート後の属性は、規定したIPアドレスやネットワークとはマッチしないソースを保有するパケットとマッチします。

条件属性(属性、インバートフラグならびにアーギュメント)のリストおよびその解説を以下に記します。

 [NOTE]
ルールの中で特定したポートは、仮想ルーター上か仮想ブリッジ上の仮想ポートです。仮想ポートは、物理的なホスト上にある特定のイーサネットインターフェース(たとえばtap)に結びついているのかもしれませんし、別の仮想ポートと対等の関係にあるのかもしれません。(その場合には仮想ポートは2つの仮想機器に接続します。)　いずれにしても、仮想ポートは仮想のものであると考えるべきです。なぜならば、各種ルールは仮想トポロジーにしか存在せず、さらに、ルールを評価している間は、仮想ポートが物理的にイーサネットのインターフェースに結びついているのかどうかは全く認知されないからです。

.CLIルールチェーン属性
[options="header"]
|===============
|属性|説明
|pos <INTEGER>:|チェーンの中におけるルールの位置
|type <TYPE>:|The rule <TYPE>; これはほとんどの場合、通常のフィルタリングルールと様々な種類のNATルールとを区別するために使われます。認知された<TYPE>バリューは次のとおりです。accept, continue, drop, jump, reject, return, dnat, snat, rev_dnat, rev_snat.
|action accept|continue
|return:|このルールアクションはNATルールにとってのみ意味を持ちます。
|jump-to <CHAIN>:|(これがもしもジャンプルールである場合)ジャンプして向かっていく先のチェーン
|target <IP_ADDRESS[-IP_ADDRESS][:INTEGER[-INTEGER]]>:|dnatルールかあるいはsnatルールである場合にはNAT標的です。少なくてもIPアドレス１つは提供しなければなりません。また、このNAT標的は任意で、２つめのアドレスを含めることにより、アドレス範囲とL4ポート番号を形成する、あるいはポートの範囲を形成することもできます。
|===============

.CLIルールチェーン属性のうちパケットとマッチするもの
[options="header"]
|===============
|Attributes That Match Packets|解説
|hw-src [!]<MAC_ADDRESS>:|ソースのハードウェアのアドレス
|hw-dst [!]<MAC_ADDRESS>:|行き先のハードウェアアドレス
|ethertype [!]<STRING>:|このルールによりマッチさせたパケットのデータリンク層(EtherType)を設定します。
|in-ports [!]<PORT[,PORT...]>:|現在パケットを処理している仮想機器にパケットが進入する時に通過をした仮想ポートをマッチさせます。
|out-ports [!]<PORT[,PORT...]>:|現在パケットを処理している仮想機器からパケットが出ていく時に通過をするポートをマッチさせます。
|tos [!]<INTEGER>:|マッチさせるべきパケットのサービス種別フィールド(TOSフィールド)のバリュー。このフィールドは、差別化されているサービスバリューをマッチさせる時に使用してください。詳細につきましてはhttps://www.ietf.org/rfc/rfc2474.txt[TOS]を参照してください。
|proto [!]<INTEGER>:|
これはマッチさせるべきIPプロトコル番号です。詳しくは次のリンクを参照してください。

http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml[Protocol Numbers]　事例は次のとおりです：ICMP = 1, IGMP = 2, TCP = 6, UDP = 17
|src [!]<CIDR>:|ソースのIPアドレスあるいはCIDRブロック
|dst [!]<CIDR>:|行き先のIPアドレスあるいはCIDRブロック
|src-port [!]<INTEGER[-INTEGER]>:|TCPソースポートあるいはUDPソースポートあるいはポートの範囲
|dst-port [!]<INTEGER[-INTEGER]>:| TCPポートあるいはUDP行き先ポートあるいはポートの範囲
|flow <fwd-flowreturn-flow>:|
    パケットのconnection-trackingステータスをマッチさせます。パケットが新たな接続を開始しようとする場合にはfwd-flowがマッチします。仮にパケットが、MidoNetが既で認知している接続に所属をしている場合には、return-flowがマッチします。
|port-group [!]<PORT_GROUP>:|
    あるポートグループをマッチさせます。各種ポートグループは仮想ポートのグループ化を許可しますが、これはチェーンルールの作成を容易にします。詳細につきましてはCLIコマンドヘルプを参照してください。
|ip-address-group-src [!]<IP_ADDRESS_GROUP>:|
    ソースのIPアドレスグループをマッチさせます。各種IPアドレスグループはIPアドレス各種のグループ化を許可しますが、これはチェーンルールの作成を容易にします。詳細につきましてはCLIコマンドヘルプを参照してください。
|ip-address-group-dst [!]<IP_ADDRESS_GROUP>:|
    行き先IPアドレスグループをマッチさせます。各種IPアドレスグループは、IPアドレスのグループ化を許可しますが、これはチェーンルールの作成を容易にします。詳細につきましてはCLIコマンドヘルプを参照してください。
|hw-src-mask|
    *ソースMACアドレスマスク*　-　48ビットのビットマスクであり形式はxxxx.xxxx.xxxxであり、ｘは十六進法の桁数であればどのような数字でもかまいません。これは、ルールのhw-srcテストを適用する時に、どのビットを考慮に入れるべきなのかを規定します。

初期設定の値　= ffff.ffff.ffff: hw-srcテストを適用する時には、ビットは全て考慮に入れますので、パケットのソースMACアドレスはhw-srcと完全にマッチしなければなりません。

    ffff.0000.0000: Hw-srcテストを適用する時には、最初の16ビットのみを考慮に入れます。パケットのソースMACアドレスの最初の16ビットは、hw-srcの最初の16ビットとマッチしなければなりません。

    0000.0000.0000: Hw-srcテストを適用する時にはビットは全く考慮に入れませんので、
　どのパケットでもマッチします。
|hw-dst-mask|
    *Destination MAC address mask* - 48ビットのビットマスクでxxxx.xxxx.xxxxの形式を持ち、ｘは16進法の桁数であればどのような数字でもかまいません。ルールのhw-dstテストを適用する時にどのビットを考慮に入れるべきであるのかを規定します。
    
Default value = ffff.ffff.ffff: hw-dstテストを適用する時には全てのビットを考慮に入れますので、パケットの行き先MACアドレスはhw-dstと完全にマッチしなければなりません。
   
 ffff.0000.0000: hw-dstテストを適用する時には最初の16ビットのみを考慮に入れます。パケットの行き先MACアドレスの最初の16ビットは、hw-dstの最初の16ビットとマッチしなければなりません。

    0000.0000.0000:　hw-dstテストを適用する時には、どのビットも考慮に入れませんの
　で、どのパケットでもマッチします。
|fragment-policy header  nonheader  any  unfragmented|
　　*fragment-policy* - マッチさせるべきフラグメント種別を規定します。
    
　　ANY: どのパケットでもマッチします。

    HEADER: フルヘッダーを持つパケットであればどのパケットともマッチします。つまり、ヘッダー断片を持つパケットでも断片ではないヘッダーを持ったパケットでもマッチします。

    NONHEADER:ヘッダーのない断片のみがマッチします。

    UNFRAGMENTED:断片化されていないパケットのみが一致します。

    一般的に、ANYが初期設定指針です。ただし、あるルールにsrcフィールドのあるいはdstフィールドの値がある場合には、NONHEADER指針ならびにANY指針は許可されず、初期設定はHEADERになります。さらに、もしもルール種別がdnatかあるいはsnatであり、そのルールの標的が単一のIPアドレスではなく、かつそのポートも規定されていないのであれば、指針はこのようなルールに対して許可される唯一の指針であるUNFRAGMENTEDに初期設定されます。

　　他のルールプロパティーとは異なり、フラグメント・ポリシーはインバートできないかもしれません。
|===============
