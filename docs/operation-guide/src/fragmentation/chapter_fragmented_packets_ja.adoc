[[handling_fragmented_packets]]
= フラグメントされたパケットのハンドリング

MidoNetにパケットがフラグメントされている場合、このセクションを参照します。

L４ルールが仮想トポロジー内に適応された時にフラグメントされたパケットがハンドリングされるルールとマッチするようにIPフラグメントを設定することができます。本機能はIPフラグメントがドロップされずに仮想トポロジーを通過することを可能にします。本機能の実装にあたり、下記のオプションがあります:

*L2/L3ファイアーウォールを書き込んでいる場合、IPフラグメントの影響をうけないようにすることができます: IPフラグメントの特殊なハンドリングは必要ありません.（L3 NATがIPフラグメントを正確にハンドリングします。）

*L4ファイアーウォールを書き込んでいる場合、IPフラグメントの特殊なハンドリングを指定します。

++++
<?dbhtml stop-chunking?>
++++

==定義と許容される値

* ヘッダー = フラグメントされていないパケットとヘッダーフラグメントが一致しているコンディションのことです。
ヘッダーはフラグメントされていないパケット、またはフラグメントされているパケットの最初のフラグメント（ヘッダーフラグメント）を指します。ヘッダーフラグメントはIPv4フラグメントオフセットのフィールドがゼロに設定されている唯一のものです. ヘッダーはルールのコンディションがL4フィールドと一致する場合、またはルールがダイナミック（それは、ポートが変更している）DNATもしくはSNATの場合、唯一の許容される値です。

* ノンヘッダー = ノンヘッダーフラグメントのみと一致しているコンディションのことです。 ノンヘッダーは、二つ目またはそれ以降のフラグメントのことを指します。

* エニー = フラグメントされている、または、されていないパケットと一致するコンディションのことです。

* アンフラグメント = フラグメントされていないパケットと一致するコンディションのことです。

[NOTE]
フラグメントポリシーの引数が設定されていない場合、ヘッダーが唯一の許容される値でない限り、セッティングはあらゆる可能性を残して処理されます。

[NOTE]
====
OpenStack Icehouseを上記に記載があるようなコンディションでMidoNetに対して実行する場合、フラグメントのハンドリングは以下のように変更されます。

L4ルールを通過する際、フラグメントをドロップするのではなく、これらのフラグメントはL4ルールに看過されます。従って、パケットがフィルターを通過する可能性もあります。

シングルL4のフローは最大で２種類生成されます。 一つ目はノンヘッダーフラグメントを処理するもので、もう一つはその他のパケットを処理するものです。
====

== フラグメントされたパケットルールチェーン生成例

チェーンを生成します。（作成されたチェーンを指すルールチェーンをエイリアスと共に生成します。事例では”chain0”がエイリアスです）。

[source]
create chain name chain0

ヘッダーフラグメントをドロップするようにチェーンにルールを追加します。

[source]
chain chain0 add rule fragment-policy header pos 2 header type drop

*例１ファイヤーウォールはフラグメントされたパケットを含みません。*

下記はフラグメントされていないパケットのみをハンドルする例です。これらはファイヤーウォールのルールで、フラグメントされたパケットを処理する前にまず着手するものです。

まず初めにファイヤーウォールの設定を行います。

* インカミングTCPポート（HTTP）トラッフィクのみを許容します。
* その他のパケットは全てドロップします。

フラグメントされたパケットのアドレス指定なしで、下記の二つのルールに基づいてルールチェーンを生成します。

* ポジション１でのルール
+
** デフォルト設定により、このルールはフラグメントされていないパケットとヘッダーフラグメントのみに一致します。
+
** protocol=TCP、destination=80でパケットを承諾します。
+
[source]
midonet> chain chain0 add rule ethertype 2048 src 0.0.0.0/0 proto 6 in-ports router2:port0 dst-port 80 pos 1 type accept

* ポジション２でのルール
+
** 全てのパケットをドロップします。
+
[source]
midonet> chain chain0 add rule ethertype 2048 src 0.0.0.0/0 dst 0.0.0.0/0 in-ports router2:port0 pos 2 type drop

[source]
midonet> chain chain0 list rule
rule rule0 ethertype 2048 src 0.0.0.0/0 proto 6 tos 0 dst-port 80 in-ports router2:port0 pos 1 type accept
rule rule1 ethertype 2048 src 0.0.0.0/0 dst 0.0.0.0/0 proto 0 tos 0 in-ports router2:port0 pos 2 type drop

上記のルールチェーンにより、MidoNetは以下にあるように行き先になるTCPポート80としてフラグメントされたパケットを処理します:

* TCPヘッダーを含む、最初半分のパケットはポジション１でのルールに到達し承諾されます。
* 一方、残り半分の行き先になるポートをもたないフラグメントはポジション１ルールに到達し、ルールのコンディションと一致しないためドロップされます。 これはフラグメントされたパケットがウェブサーバーに到達しないことを意味します。

*例２ファイヤーウォールはフラグメントされたパケットをアドレス指定します。*

この問題を特定するために、MidoNetはフラグメントされたパケットを処理するメカニズムを提供しています。下記の例にあるように、このメカニズムによりフラグメントされたパケットをそれぞれの行き先に到達させることができます。下記イメージに、ヘッダーとノンヘッダーの２部を含むフラグメントされていないパケットとフラグメントされているパケットの全体像が描写されています。

image::packet_fragments.png[]

== フラグメントされていないパケットとフラグメントされているパケット

本例には以下のパケットが含まれています。

* 行き先がTCPポート80のフラグメントされていないパケット
* 行き先がTCPポート80のフラグメントされているパケット
* 行き先がTCPポート72のフラグメントされていないパケット
* 行き先がTCPポート72のフラグメントされているパケット
image::packet_fragments_multiple_ports.png[]

== 異なった行き先をもつフラグメントされたパケットとフラグメントされていないパケット

例１にあるルールとパケットに基づいて、MidoNetは以下のようにパケットを処理します。

* パケット１とポジション１ルールが一致すると承諾されます。

* パケット２のヘッダーパートがポジション１ルールと一致する場合承諾されます; 行き先のないノンヘッダーフラグメントはルールと一致しないのでドロップされます。

* パケット３の行き先がポジション１ルールと一致しない場合、パケット４のヘッダーパートと同様にドロップされます。パケット４のノンヘッダーパートに行き先の情報がない場合もドロップされます。

はじめの目的は、ヘッダーを含むフラグメントされているパケットパートを承諾することです。これをするためにポジション１で同様のルールを生成します。 そして、TCP/UDPヘッダーを含む全てのパケットをドロップするためにポジション２にて新たなルールを追加します。

* ポジション１ルール
+
** デフォルト設定により、このルールはフラグメントされていないパケットとヘッダーフラグメントを一致させます。
+
** protocol=TCP、destination=80を含むin-ports=router2:port0からのパケットを承諾します。
+
[source]
midonet> chain chain18 add rule ethertype 2048 src 0.0.0.0/0 proto 6 in-ports router2:port0 dst-port 80 pos 1 type accept

* ポジション２ルール
+
** TCP/UDPヘッダーを含むパケットをドロップします。
+
[source]
midonet> chain chain18 add rule ethertype 2048 src 0.0.0.0/0 in-ports router2:port0 fragment-policy header pos 2 type drop

* ポジション３ルール
+
** その他全てのパケットを承諾します。
+
[source]
midonet> chain chain18 add rule ethertype 2048 src 0.0.0.0/0 in-ports router2:port0 dst 0.0.0.0/0 pos 3 type accept

ポート72行きのパケットからはじまる上記にあるパケットが、新たに設定されたルールチェーンをどのように進行するかを参照します。

* パケット３の行き先はポート72であってポート80とは異なります。 よってポジション１ルールと一致しないため、ポジション２ルールに進みます。

* パケット３はTCPヘッダーを含みます。ポジション２ルールと一致するためにドロップされます。

* パケット４のヘッダーフラグメントはポート72への行き先を含むため、ポジション１ルールと一致せず、ポジション２ルールへと進みます。

* このフラグメントはTCPヘッダーを含み、ポジション２ルールと一致するためドロップされます。

* パケット4のノンヘッダーフラグメントはヘッダーを含まない（つまり行き先の情報がない）ため、ポジション１ルールと一致せずポジション２ルールへと進みます。

* このノンヘッダーパケットフラグメントはTCP/UDPヘッダーを含まないためポジション２ルールと一致せず、ポジション３ルールへと進みます。

* ポジション３ルールでは、ここに到達する全てのパケットフラグメントを承諾します。関連するヘッダー情報がないために、再構成されずにアプリケーションに送られ、いずれドロップされます。

パケット１と２を参照します。

* パケット１の行き先がTCPポート80でポジション１ルールと一致するため承諾されます。

* パケット２では、TCPポート80の行き先を含むヘッダーをもつパケットフラグメントはポジション１ルールと一致するため承諾されます。

* ノンヘッダーパケットフラグメントをもつパケット２はヘッダーを持たず、ポジション１ルールと一致しないためポジション２ルールへと進みます。

* このノンヘッダーパケットフラグメントはTCP/UDPヘッダーを含まないためポジション２ルールと一致せずドロップされ、ポジション３ルールへと進みます。

* ポジション３ルールでは、全てのパケットを承諾するため、このパケットフラグメントも承諾されます。

この変更によってノンヘッダーフラグメントがポジション１と２ルールを通過することができ、ルールチェーンを承諾して終了することができます。 また、この変更によりファイヤーウォールは全てのノンヘッダーフラグメントを通過させますが、リスクレベルが許容範囲にあると判断され、不適切なHTTPフローの修正を行います。該当するヘッダーフラグメントが受信されない限り、必要とされないノンヘッダーフラグメントは削除されるため、問題にはなりません。
